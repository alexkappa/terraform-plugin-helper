// +build ignore

package main

import (
	"bytes"
	"fmt"
	"go/format"
	"io/ioutil"
	"os"
	"strings"
	"text/template"
)

type data struct {
	Func    string
	Type    string
	TypeVar string
}

func main() {
	types := []string{
		"string",
		"bool",
		// "int8", "uint8",
		// "int16", "uint16",
		"int32", "uint32",
		"int64", "uint64",
		"int", "uint",
		"float32", "float64",
		"complex64", "complex128",
	}

	t := template.Must(template.New("tmpl").Parse(tmpl))

	d := make([]data, len(types))

	for i := 0; i < len(types); i++ {
		d[i] = data{
			Func:    strings.Title(types[i]),
			Type:    types[i],
			TypeVar: string(types[i][0]),
		}
	}

	var buf bytes.Buffer
	err := t.Execute(&buf, d)
	if err != nil {
		errorf("Failed executing template. %s\n", err)
	}

	clean, err := format.Source(buf.Bytes())
	if err != nil {
		errorf("Failed formatting source code. %s\n%s\n", err, buf.Bytes())
	}

	err = ioutil.WriteFile("expand.gen.go", clean, 0644)
	if err != nil {
		errorf("Failed writing file. %s\n", err)
	}
}

func errorf(f string, v ...interface{}) {
	fmt.Fprintf(os.Stderr, f, v...)
	os.Exit(1)
}

const tmpl = `// Code generated by gen-accessors; DO NOT EDIT.
package expand

import "github.com/alexkappa/terraform-plugin-helper"

{{range .}}
// {{.Func}} accesses the value held by key and type asserts it as a {{.Type}}.
func {{.Func}}(d helper.Data, key string) ({{.TypeVar}} {{.Type}}) {
	v, ok := get(d, key)
	if ok {
		{{.TypeVar}} = v.({{.Type}})
	}
	return
}

// {{.Func}}Ptr accesses the value held by key and type asserts it as a pointer to
// a {{.Type}}.
func {{.Func}}Ptr(d helper.Data, key string) ({{.TypeVar}} *{{.Type}}) {
	v, ok := get(d, key)
	if ok {
		tmp := v.({{.Type}})
		{{.TypeVar}} = &tmp
	}
	return
}
{{end}}
`
